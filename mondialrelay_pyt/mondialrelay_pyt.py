#!/usr/bin/env python
# -*- coding: utf-8 -*-
##############################################################################
#
#    mondialrelaiy_pyt
#    (Mondial Relay Python)
#
#    Copyright (C) 2012 Akretion
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
"""

    mondialrelay_pyt is a Python library made to interact with
    the Mondial Relay's Web Service API : WSI2_CreationEtiquette
    (http://www.mondialrelay.fr/webservice/WSI2_CreationEtiquette)

    It takes a dictionnary of values required and the format of label wanted
    and gives the tracking number, and the url to donwload the label in pdf.

"""

__author__ = "Sébastien BEAU / Aymeric LECOMTE"
__version__ = "0.1.0"
__date__ = "2012-12-06"

# TO IMPROVE:
#
# Decembre 2012, 12th :
# - real namespaces management
# - encoding issues
#   => if a dictionnary is given with caracters such as é, è...
#       the library is NOT able to manage it:
#           lxml generates *unicode* string from the xml tree, but hashlib.md5 creates keys from *utf-8*.
#           It's a problem because the md5 key sent must match with the one generated by Mondial Relay
#           (made with other sent values)
#       Status code 97 will be returned by Mondial relay ('Error: Different Security keys')
#




#-----------------------------------------#
#               LIBRARIES                 #
#-----------------------------------------#

from lxml import etree, objectify
from hashlib import md5
from requests.auth import HTTPBasicAuth
import requests
import re
import collections


#-----------------------------------------#
#               CONSTANTS                 #
#-----------------------------------------#

HOST= 'www.mondialrelay.fr'
ENCODE = '<?xml version="1.0" encoding="utf-8"?>'

MR_KEYS = collections.OrderedDict([
    ('Enseigne',"^[0-9A-Z]{2}[0-9A-Z]{6}$"),
    ('ModeCol',"^(CCC|CDR|CDS|REL)$"),
    ('ModeLiv',"^(LCC|LD1|LDS|24R|ESP|DRI)$"),
    ('NDossier',"^(|[0-9A-Z_ -]{0,15})$"),
    ('NClient',"^(|[0-9A-Z]{0,9})$"),
    ('Expe_Langage',"^[A-Z]{2}$"),
    ('Expe_Ad1',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Expe_Ad2',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Expe_Ad3',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Expe_Ad4',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Expe_Ville',"^[A-Z_\-' ]{2,26}$"),
    ('Expe_CP',"^[0-9]{5}$"),
    ('Expe_Pays',"^[A-Z]{2}$"),
    ('Expe_Tel1',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Expe_Tel2',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Expe_Mail',"^[\w\-\.\@_]{7,70}$"),
    ('Dest_Langage',"^[A-Z]{2}$"),
    ('Dest_Ad1',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Dest_Ad2',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Dest_Ad3',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Dest_Ad4',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Dest_Ville',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Dest_CP',"^[0-9]{5}$"),
    ('Dest_Pays',"^[A-Z]{2}$"),
    ('Dest_Tel1',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Dest_Tel2',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Dest_Mail',"^[\w\-\.\@_]{7,70}$"),
    ('Poids',"^[0-9]{3,7}$"),
    ('Longueur',"^[0-9]{0,3}$"),
    ('Taille',"^{0}$"),
    ('NbColis',"^[0-9]{1,2}$"),
    ('CRT_Valeur',"^[0-9]{1,7}$"),
    ('CRT_Devise',"^(|EUR)$"),
    ('EXP_Valeur',"^[0-9]{0,7}$"),
    ('EXP_Devise',"^(|EUR)$"),
    ('COL_Rel_Pays',"^[A-Z]{2}$"),
    ('COL_Rel',"^(|[0-9]{6})$"),
    ('LIV_Rel_Pays',"^[A-Z]{2}$"),
    ('LIV_Rel',"^(|[0-9]{6})$"),
    ('TAvisage',"^(|O|N)$"),
    ('TReprise',"^(|O|N)$"),
    ('Montage',"^(|[0-9]{1,3})$"),
    ('TRDV',"^(|O|N)$"),
    ('Assurance',"^(|[0-9A-Z]{1})$"),
    ('Instructions',"^[0-9A-Z_\-'., /]{0,31}"),
    ('Texte',"^([^<>&']{3,30})(\(cr\)[^<>&']{0,30})")
    ])

#------------------------------------------#
#       Mondial Relay WEBService           #
#        WSI2_CreationEtiquette            #
#------------------------------------------#

class MRWebService(object):

    def __init__(self, security_key):
        self.security_key = security_key

    def valid_dict(self, dico):
        ''' Get a dictionnary, check if all required fields are provided,
        and if the values correpond to the required format.'''

        mandatory = [
            'Enseigne',
            'ModeCol',
            'ModeLiv',
            'Expe_Langage',
            'Expe_Ad1',
            'Expe_Ad3',
            'Expe_Ville',
            'Expe_CP',
            'Expe_Pays',
            'Expe_Tel1',
            'Dest_Langage',
            'Dest_Ad1',
            'Dest_Ad3',
            'Dest_Ville',
            'Dest_CP',
            'Dest_Pays',
            'Poids',
            'NbColis',
            'CRT_Valeur',
            ]


        if ('ModeLiv' or 'ModeCol') not in dico:
            raise Exception('The given dictionnary is not valid.')

        for element in dico:
            if element not in MR_KEYS:
                raise Exception('Key %s not valid in given dictionnary' %element)
            formt = MR_KEYS[element]
            if re.match(formt, dico[element].upper()) == None:
                raise Exception('Value %s not valid in given dictionary, key %s, expected format %s' %(dico[element],element, MR_KEYS[element]))

        if dico['ModeLiv'] == "24R":
            mandatory.insert(19,'LIV_Rel')
            mandatory.insert(19,'LIV_Rel_Pays')
        if dico['ModeCol'] == "REL":
            mandatory.insert(19,'COL_Rel')
            mandatory.insert(19,'COL_Rel_Pays')
        if dico['ModeLiv'] == "LDS":
            mandatory.insert(16,'Dest_Tel1')

        for mandatkey in mandatory:
            if mandatkey not in dico:
                raise Exception('Mandatory key %s not given in the dictionnary' %mandatkey)

        return True

    #------------------------------------#
    #      functions to clean the xml    #
    #------------------------------------#

    def clean_xmlrequest(self, xml_string):
        ''' [XML REQUEST]
        Ugly hardcode to get ride of specifics headers declarations or namespaces instances.
        Used in the xml before sending the request.
        See http://lxml.de/tutorial.html#namespaces or http://effbot.org/zone/element-namespaces.htm
        to improve the library and manage namespaces properly '''

        env='<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'+' xmlns:xsd="http://www.w3.org/2001/XMLSchema"'+' xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'
        wsietiq='<WSI2_CreationEtiquette xmlns="http://www.mondialrelay.fr/webservice/">'

        str1 = xml_string.replace('soapBody','soap:Body').replace('soapEnvelope','soap:Envelope')
        str2 = str1.replace('<soap:Envelope>',env)
        str3 = str2.replace('<WSI2_CreationEtiquette>',wsietiq)

        return str3

    def clean_xmlresponse(self, xml_string):
        ''' [XML RESPONSE]
        Ugly hardcode to get ride of specifics headers declarations or namespaces instances.
        Used in the xml after receiving the response.
        See http://lxml.de/tutorial.html#namespaces or http://effbot.org/zone/element-namespaces.htm
        to improve the library and manage namespaces properly '''

        head = ' xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"'
        env = 'soap:Envelope'
        body= 'soap:Body'
        xmlns=' xmlns="http://www.mondialrelay.fr/webservice/"'

        str1 = xml_string.replace(head,'').replace(env,'soapEnvelope').replace(body,'soapBody').replace(xmlns,'')
        str2 = str1.replace(ENCODE,'')

        return str2

    #------------------------------------#
    #    functions to manage the xml     #
    #------------------------------------#

    def create_xmlrequest(self, vals):
        '''[XML REQUEST]
        Creates an xml tree fitted to the soap request to WSI2_CreationEtiquette,
        from the given dictionnary. All dictionnary's keys must correspond to a field to pass.

        IN = Dictionnary
        OUT = XML (as an utf-8 encoded string) ready to send a request '''

        #check if the given dictionnary is correct to make an xml
        mandat_dic = MRWebService.valid_dict(self, vals)

        #initialisation of future md5key
        security = ""

        # beginning of the xml tree, to be modified later with soapclean_xml()
        envl = etree.Element('soapEnvelope')
        body = etree.SubElement(envl, 'soapBody')
        wsi2_crea = etree.SubElement(body,'WSI2_CreationEtiquette')

        # xml elements creation
        for key in MR_KEYS:
           if key != 'Texte':
                xml_element = etree.SubElement(wsi2_crea,key)
                xml_element.text = vals.get(key, '')
                security += vals.get(key,'')

        # generates <Security/> xml element
        security+=self.security_key
        md5secu = md5(security).hexdigest().upper()

        print "Security string : ", security, "\n"
        print "MD5 Key : ", md5secu, "\n"

        xml_security = etree.SubElement(wsi2_crea, "Security" )
        xml_security.text = md5secu

        # add <Text/> last xml element if present, not included in security key
        if 'Texte' in vals:
            xml_element = etree.SubElement(wsi2_crea,"Texte")
            xml_element.text = vals['Texte']

        # generates and modifies the xml tree to obtain an apropriate xml soap string
        xmltostring = etree.tostring(envl, encoding='utf-8', pretty_print=True)
        xmlrequest = MRWebService.clean_xmlrequest(self,xmltostring)
        print"#============ XML REQUEST=============#\n",xmlrequest,"==================="

        return xmlrequest

    def sendsoaprequest(self, xml_string):
        ''' Send the POST request to the Web Service.
        IN = proper xml-string
        OUT = response from the Web Service, in an xml-string utf-8'''

        header = {
            'POST': '/webservice/Web_Services.asmx',
            'Host': HOST,
            'Content-Type': 'text/xml',
            'charset': 'utf-8',
            'Content-Lenght': 'Lenght',
            'SOAPAction': 'http://www.mondialrelay.fr/webservice/WSI2_CreationEtiquette',
        }

        url="http://www.mondialrelay.fr/WebService/Web_Services.asmx?op=WSI2_CreationEtiquette"

        #TODO: do not hardcode connexion values
        response=requests.post(url,headers=header, data=xml_string, auth=('BDTEST12','MRT_2012'))

        print "\n======SOAP RESPONSE =========\n", response, "\n=========================\n"
        return response.content

    def parsexmlresponse(self,soap_response):
        ''' Parse the response given by the WebService.
        Extract and returns all fields' datas.
        IN = xml-string utf-8 returned by Mondial Relay
        OUT : Dictionnary or Error'''

        strresp = soap_response
        strresp = strresp.replace(ENCODE,'')
        tree= etree.fromstring(strresp)
        string = etree.tostring(tree, pretty_print=True, encoding='utf-8')
        print "\n======SOAP RESPONSE'S CONTENT =========\n", string, "\n=========================\n"

        response =  MRWebService.clean_xmlresponse(self, soap_response)
        soapEnvelope = objectify.fromstring(response)
        print "\n===== LXML Objectified Tree ======\n",objectify.dump(soapEnvelope),"\n=========================\n"

        #---------------Parsing---------------#
        stat = soapEnvelope.soapBody.WSI2_CreationEtiquetteResponse.WSI2_CreationEtiquetteResult.STAT

        if stat == 0:
            NumExpe = soapEnvelope.soapBody.WSI2_CreationEtiquetteResponse.WSI2_CreationEtiquetteResult.ExpeditionNum
            urlpdf = 'http://'+HOST+soapEnvelope.soapBody.WSI2_CreationEtiquetteResponse.WSI2_CreationEtiquetteResult.URL_Etiquette
            resultat={'STAT':stat,'ExpeditionNum':NumExpe,'URL_Etiquette':urlpdf}
        else:
            resultat={'STAT':stat}
            raise Exception('The server return %s . Please check mondial relay documentation for help' %stat)

        return resultat

        return True

    #------------------------------------#
    #       FUNCTION TO CALL             #
    #------------------------------------#
    def make_shipping_label(self, dictionnary, labelformat):
        ''' FUNCTION TO CALL TO GET DATAS WANTED FROM THE WEB SERVICE
        IN = Dictionnary with corresponding keys (see MR_Keys or Mondial Relay's Documentation)
        OUT = Raise an error with indications (see MR Doc for numbers correspondances)
        or Expedition Number and URL to PDF'''

        print "\n##### MAKE SHIPPING LABEL - MONDIAL RELAY #####\n##### WSI2_CreationEtiquette #####\n"

        print "\n+++call MRWebService.create_xmlrequest(self,vals)+++\n"
        xmlstring = MRWebService.create_xmlrequest(self, dictionnary)

        print "\n+++call MRWebService.sendsoaprequest(self,xmlstring)+++\n"
        resp = MRWebService.sendsoaprequest(self,xmlstring)

        print "\n+++call  MRWebService.parsexml(self,resp)+++\n"
        result = MRWebService.parsexmlresponse(self,resp)

        url = result['URL_Etiquette']
        if labelformat == 'A4':
            url = url.replace('format=A5','format=A4')
        if labelformat == 'A5':
            url = url.replace('format=A4','format=A5')

        final = {
                'ExpeditionNum': result['ExpeditionNum'],
                'URL_Etiquette': url,
                'format':labelformat,
                }

        print "\n============== FINAL DICTIONNARY RETURNED ==============\n",final,"\n================================\n"

        return final

