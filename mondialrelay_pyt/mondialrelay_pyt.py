#!/usr/bin/env python
# -*- coding: utf-8 -*-
##############################################################################
#
#    mondialrelaiy_pyt
#    (Mondial Relay Python)
#
#    Copyright (C) 2012 Akretion
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
"""

    mondialrelay_pyt is a Python library made to interact with the Mondial Relay's Web Service API.
    http://www.mondialrelay.fr/webservice/WSI2_CreationEtiquette

"""

__author__ = "Sébastien BEAU / Aymeric LECOMTE"
__version__ = "0.1.0"
__date__ = "2012-12-06"

# TO IMPROVE:
#
# Decembre 2012, 12th :
# - real namespaces management
# - encoding issues
#   => if a dictionnary is given with caracters such as é, è...
#       the library is NOT able to manage it:
#           lxml generates *unicode* string from the xml tree, but hashlib.md5 creates keys from *utf-8*.
#           It's a problem because the md5 key sent must match with the one generated by Mondial Relay
#           (made with other sent values)
#       Status code 97 will be returned by Mondial relay ('Error: Different Security keys')
#




#-----------------------------------------#
#               LIBRARIES                 #
#-----------------------------------------#

from lxml import etree, objectify
from hashlib import md5
from requests.auth import HTTPBasicAuth
import requests
import re
import collections


#-----------------------------------------#
#               CONSTANTS                 #
#-----------------------------------------#

HOST= 'www.mondialrelay.fr'
ENCODE = '<?xml version="1.0" encoding="utf-8"?>'

MR_KEYS = collections.OrderedDict([
    ('Enseigne',"^[0-9A-Z]{2}[0-9A-Z]{6}$"),
    ('ModeCol',"^(CCC|CDR|CDS|REL)$"),
    ('ModeLiv',"^(LCC|LD1|LDS|24R|ESP|DRI)$"),
    ('NDossier',"^(|[0-9A-Z_ -]{0,15})$"),
    ('NClient',"^(|[0-9A-Z]{0,9})$"),
    ('Expe_Langage',"^[A-Z]{2}$"),
    ('Expe_Ad1',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Expe_Ad2',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Expe_Ad3',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Expe_Ad4',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Expe_Ville',"^[A-Z_\-' ]{2,26}$"),
    ('Expe_CP',"^[0-9]{5}$"),
    ('Expe_Pays',"^[A-Z]{2}$"),
    ('Expe_Tel1',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Expe_Tel2',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Expe_Mail',"^[\w\-\.\@_]{7,70}$"),
    ('Dest_Langage',"^[A-Z]{2}$"),
    ('Dest_Ad1',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Dest_Ad2',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Dest_Ad3',"^[0-9A-Z_\-'., /]{2,32}$"),
    ('Dest_Ad4',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Dest_Ville',"^[0-9A-Z_\-'., /]{0,32}$"),
    ('Dest_CP',"^[0-9]{5}$"),
    ('Dest_Pays',"^[A-Z]{2}$"),
    ('Dest_Tel1',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Dest_Tel2',"^((00|\+)33|0)[0-9][0-9]{8}$"),
    ('Dest_Mail',"^[\w\-\.\@_]{7,70}$"),
    ('Poids',"^[0-9]{3,7}$"),
    ('Longueur',"^[0-9]{0,3}$"),
    ('Taille',"^{0}$"),
    ('NbColis',"^[0-9]{1,2}$"),
    ('CRT_Valeur',"^[0-9]{1,7}$"),
    ('CRT_Devise',"^(|EUR)$"),
    ('EXP_Valeur',"^[0-9]{0,7}$"),
    ('EXP_Devise',"^(|EUR)$"),
    ('COL_Rel_Pays',"^[A-Z]{2}$"),
    ('COL_Rel',"^(|[0-9]{6})$"),
    ('LIV_Rel_Pays',"^[A-Z]{2}$"),
    ('LIV_Rel',"^(|[0-9]{6})$"),
    ('TAvisage',"^(|O|N)$"),
    ('TReprise',"^(|O|N)$"),
    ('Montage',"^(|[0-9]{1,3})$"),
    ('TRDV',"^(|O|N)$"),
    ('Assurance',"^(|[0-9A-Z]{1})$"),
    ('Instructions',"^[0-9A-Z_\-'., /]{0,31}"),
    ('Texte',"^([^<>&']{3,30})(\(cr\)[^<>&']{0,30})")
    ])

#------------------------------------------#
#       Mondial Relay WEBService           #
#        WSI2_CreationEtiquette            #
#------------------------------------------#

class MRWebService(object):

    def __init__(self, security_key):
        self.security_key = security_key

    def valid_dict(self, dico):
        ''' Get a dictionnary, check if all required fields are provided,
        and if the values correpond to the required format.
        Respecting the order in the 'mandatory' list is just a commodity,
        it's not required as it is in the MR_KEYS ordered dictionay.'''

        mandatory = [
            'Enseigne', #0
            'ModeCol',
            'ModeLiv',
            'Expe_Langage',
            'Expe_Ad1',
            'Expe_Ad3', #5
            'Expe_Ville',
            'Expe_CP',
            'Expe_Pays',
            'Expe_Tel1',
            'Dest_Langage',#10
            'Dest_Ad1',
            'Dest_Ad3',
            'Dest_Ville',
            'Dest_CP',
            'Dest_Pays',#15
            'Poids',
            'NbColis',
            'CRT_Valeur',#18
            ]


        if ('ModeLiv' or 'ModeCol') not in dico:
            raise Exception('The given dictionnary is not valid.')

        for element in dico:
            if element not in MR_KEYS:
                raise Exception('Key %s not valid in given dictionnary' %element)
            formt = MR_KEYS[element]
            if re.match(formt, dico[element].upper()) == None:
                raise Exception('Value %s not valid in given dictionary, key %s, expected format %s' %(dico[element],element, MR_KEYS[element]))

        if dico['ModeLiv'] == "24R":
            mandatory.insert(19,'LIV_Rel')
            mandatory.insert(19,'LIV_Rel_Pays')
        if dico['ModeCol'] == "REL":
            mandatory.insert(19,'COL_Rel')
            mandatory.insert(19,'COL_Rel_Pays')
        if dico['ModeLiv'] == "LDS":
            mandatory.insert(16,'Dest_Tel1')

        for mandatkey in mandatory:
            if mandatkey not in dico:
                raise Exception('Mandatory key %s not given in the dictionnary' %mandatkey)

        return True

    def soapclean_xml(self, xml_string):
        ''' [XML REQUEST] Ugly hardcode to get ride of specifics headers declarations or namespaces instances.
        Used in the xml before sending the request.
        See http://lxml.de/tutorial.html#namespaces or http://effbot.org/zone/element-namespaces.htm
        to improve the library and manage namespaces properly '''

        env='<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'+' xmlns:xsd="http://www.w3.org/2001/XMLSchema"'+' xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'
        wsietiq='<WSI2_CreationEtiquette xmlns="http://www.mondialrelay.fr/webservice/">'

        str1 = xml_string.replace('soapBody','soap:Body').replace('soapEnvelope','soap:Envelope')
        str2 = str1.replace('<soap:Envelope>',env)
        str3 = str2.replace('<WSI2_CreationEtiquette>',wsietiq)

        return str3

    def clean_response(self, strg):
        ''' [XML RESPONSE] Ugly hardcode to get ride of specifics headers declarations or namespaces instances.
        Same as soapclean_xml but for the xml returned by the server.
        See http://lxml.de/tutorial.html#namespaces or http://effbot.org/zone/element-namespaces.htm
        to improve the library and manage namespaces properly '''

        head = ' xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"'
        env = 'soap:Envelope'
        body= 'soap:Body'
        xmlns=' xmlns="http://www.mondialrelay.fr/webservice/"'
        strg = strg.replace(head,'').replace(env,'soapEnvelope').replace(body,'soapBody').replace(xmlns,'')
        strg = strg.replace(ENCODE,'')
        return strg

    def create_xmlrequest(self, vals):
        '''Creates an xml tree fitted to the soap request to WSI2_CreationEtiquette,
        from the given dictionnary. All dictionnary's keys must correspond to a field to pass.

        IN = Dictionnary
        OUT = XML (as an utf-8 encoded string) ready to send a request '''

        #check if the given dictionnary is correct to make an xml
        mandat_dic = MRWebService.valid_dict(self, vals)

        #initialisation of future md5key
        security = ""

        # beginning of the xml tree, to be modified later with soapclean_xml()
        envl = etree.Element('soapEnvelope')
        body = etree.SubElement(envl, 'soapBody')
        wsi2_crea = etree.SubElement(body,'WSI2_CreationEtiquette')

        # xml elements creation
        for key in MR_KEYS:
           if key != 'Texte':
                xml_element = etree.SubElement(wsi2_crea,key)
                xml_element.text = vals.get(key, '')
                security += vals.get(key,'')

        # generates <Security/> xml element
        security+=self.security_key
        md5secu = md5(security).hexdigest().upper()

        print "Security string : ", security, "\n"
        print "MD5 Key : ", md5secu, "\n"

        xml_security = etree.SubElement(wsi2_crea, "Security" )
        xml_security.text = md5secu

        # add <Text/> last xml element if present, not included in security key
        if 'Texte' in vals:
            xml_element = etree.SubElement(wsi2_crea,"Texte")
            xml_element.text = vals['Texte']

        # generates and modifies the xml tree to obtain an apropriate xml soap string
        xmltostring = etree.tostring(envl, encoding='utf-8', pretty_print=True)
        xmlrequest = MRWebService.soapclean_xml(self,xmltostring)
        print"#============ XML REQUEST=============#\n",xmlrequest,"==================="

        return xmlrequest

    def sendsoaprequest(self, xml_string):
        ''' Send the POST request to the Web Service.
        IN = proper xml-string
        OUT = response from the Web Service, in an xml-string utf-8'''

        header = {
            'POST': '/webservice/Web_Services.asmx',
            'Host': HOST,
            'Content-Type': 'text/xml',
            'charset': 'utf-8',
            'Content-Lenght': 'Lenght',
            'SOAPAction': 'http://www.mondialrelay.fr/webservice/WSI2_CreationEtiquette',
        }

        url="http://www.mondialrelay.fr/WebService/Web_Services.asmx?op=WSI2_CreationEtiquette"
        #TODO: do not hardcode connexion values
        response=requests.post(url,headers=header, data=xml_string, auth=('BDTEST12','MRT_2012'))
        print response
#        strresp = req.text
#        strresp = strresp.replace(ENCODE,'')
#        tree= etree.fromstring(strresp)
#        string = etree.tostring(tree, pretty_print=True, encoding='utf-8')
#
#        print "#---------REQUEST---------#"
#        print "header request======\n",header,"\n"
#        print "req"
#        print req
#        print "req.content----------"
#        print req.content
#        print "req.text----------"
#        print req.text
#        print "req.headers----------"
#        print req.headers
#        print "----------"
#        print string
#        print "req.reason: ", req.reason
#        print "request: ", req.request
#        print "url: ", req.url
#        print "config: ", req.config
#        print "http error: ", req.error
#        print "encoding: ", req.encoding
#        print "raise for status: ", req.raise_for_status
#        print "#---------------------------#"

        return response.content

    def parsexmlresponse(self,soap_response):
        ''' Parse the response given by the WebService.
        Extract and returns all fields' datas.
        IN = xml-string utf-8 returned by Mondial Relay
        OUT : Dictionnary or Error'''

        #------- Prompt of the response -------#
        print "======SOAP RESPONSE ========="
        print soap_response
        print "= = = = = = = = = = ="

        strresp = soap_response
        strresp = strresp.replace(ENCODE,'')
        tree= etree.fromstring(strresp)
        string = etree.tostring(tree, pretty_print=True, encoding='utf-8')
        print string

        #---------------Parsing---------------#
        response =  MRWebService.clean_response(self, soap_response)

        soapEnvelope = objectify.fromstring(response)
        print "===== LXML Objectified Tree ======\n",objectify.dump(soapEnvelope),"\n==============="

        stat = soapEnvelope.soapBody.WSI2_CreationEtiquetteResponse.WSI2_CreationEtiquetteResult.STAT

        if stat == 0:
            NumExpe = soapEnvelope.soapBody.WSI2_CreationEtiquetteResponse.WSI2_CreationEtiquetteResult.ExpeditionNum
            urlpdf = 'http://'+HOST+soapEnvelope.soapBody.WSI2_CreationEtiquetteResponse.WSI2_CreationEtiquetteResult.URL_Etiquette
            resultat={'STAT':stat,'ExpeditionNum':NumExpe,'URL_Etiquette':urlpdf}
        else:
            resultat={'STAT':stat}
            raise Exception('The server return %s . Please check mondial relay documentation for help' %stat)

        return resultat

        #tree_resp = etree.fromstring(response)
        #print etree.tostring(tree_resp,pretty_print=True)
        #stat = tree_resp.findtext("{http://www.mondialrelay.fr/webservice/}STAT")
        #print stat
        #num_expe = tree_resp.findtext("ExpeditionNum")
        #url_etiq = tree_resp.findtext("URL_Etiquette")
        #isnum_expe = tree_resp.find("ExpeditionNum")
        #isurl_etiq = tree_resp.find("URL_Etiquette")

        #print num_expe
        #print url_etiq
        #print isnum_expe
        #print isurl_etiq

        #for field in ['ExpeditionNum','URL_Etiquette']:
        #    field_data = tree_resp.findtext(".//"+field)

        #    if not field_data or field_data == '':
        #        xml_resp = etree.tostring(tree_resp, pretty_print=True)
        #        raise Exception("Field '%s' not found or empty in xml response "
        #            "from Mondial Relay.\n Please contact your Web Service "
        #            "provider.\n XML Response : \n'%s'\n" %(field, xml_resp))
        #    else:
        #        num_expe = tree_resp.findtext(".//ExpeditionNum")
        #        url_etiq = tree_resp.findtext(".//URL_Etiquette")

        return True

    #---------------------------#
    #   WSI2_GetEtiquettes       #
    #---------------------------#

    def get_label(self, vals, result):

        #gets all the values and puts them in an ordered dictionnary
        dict_val=collections.OrderedDict([
            ('Enseigne',vals.get('Enseigne','')),
            ('Expeditions',unicode(result.get('ExpeditionNum',''))),
            ('Langue',vals.get('Expe_Langage',''))
        ])

        # beginning of the xml tree, to be modified later with soapclean_xml()
        envl = etree.Element('soapEnvelope')
        body = etree.SubElement(envl, 'soapBody')
        wsi2_get = etree.SubElement(body,'WSI2_GetEtiquettes')


        #creates security check specific to the request
        security = ""
        for key in dict_val:
            xml_element = etree.SubElement(wsi2_get,key)
            xml_element.text = dict_val.get(key, '')
            security += dict_val[key]

        security += self.security_key
        md5secu = md5(security).hexdigest().upper()

        #finish the xml to send
        xml_security = etree.SubElement(wsi2_get, "Security" )
        xml_security.text = md5secu

        xml_string = etree.tostring(envl, encoding='utf-8', pretty_print=True)

        #prepare and clean XML
        env='<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'+' xmlns:xsd="http://www.w3.org/2001/XMLSchema"'+' xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'
        wsietiq='<WSI2_GetEtiquettes xmlns="http://www.mondialrelay.fr/webservice/">'

        str1 = xml_string.replace('soapBody','soap:Body').replace('soapEnvelope','soap:Envelope')
        str2 = str1.replace('<soap:Envelope>',env)
        xml_request = str2.replace('<WSI2_GetEtiquettes>',wsietiq)

        print"#============ XML REQUEST GET ETIQUETTES=============#\n",xml_request,"==================="

        #Send SOAP Request

        header = {
            'POST': '/webservice/Web_Services.asmx',
            'Host': HOST,
            'Content-Type': 'text/xml',
            'charset': 'utf-8',
            'Content-Lenght': 'Lenght',
            'SOAPAction': 'http://www.mondialrelay.fr/webservice/WSI2_GetEtiquettes',
        }

        url="http://www.mondialrelay.fr/WebService/Web_Services.asmx?op=WSI2_GetEtiquettes"
        #TODO: do not pass hardcoded connexion variables
        response=requests.post(url,headers=header, data=xml_request, auth=('BDTEST12','MRT_2012'))

        print "#============ XML RESPONSE GET ETIQUETTES=============#\n",response.content,"==================="

        # response parsing

        strresp = response.content
        #strresp = strresp.replace(ENCODE,'')
        tree= etree.fromstring(strresp)
        string = etree.tostring(tree, pretty_print=True, encoding='utf-8')
        print string

        head = ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"'
        env = 'soap:Envelope'
        body= 'soap:Body'
        xmlns=' xmlns="http://www.mondialrelay.fr/webservice/"'
        string = string.replace(head,'').replace(env,'soapEnvelope').replace(body,'soapBody').replace(xmlns,'')
        string = string.replace(ENCODE,'')

        soapEnvelope = objectify.fromstring(string)
        print "===== LXML Objectified Tree ======\n",objectify.dump(soapEnvelope),"\n==============="

        urla4 = 'http://'+HOST+soapEnvelope.soapBody.WSI2_GetEtiquettesResponse.WSI2_GetEtiquettesResult.URL_PDF_A4
        urla5 = 'http://'+HOST+soapEnvelope.soapBody.WSI2_GetEtiquettesResponse.WSI2_GetEtiquettesResult.URL_PDF_A5

        return {'url_pdf_a4': urla4, 'url_pdf_a5': urla5}



    # FUNCTION TO CALL #
    def make_shipping_label(self, vals, labelformat):
        ''' FUNCTION TO CALL TO GET THE DATAS WANTED FROM THE WEB SERVICE
        IN = Dictionnary with corresponding keys (see MR_Keys or Mondial Relay's Documentation)
        OUT = Raise an error with indications (see MR Doc for numbers correspondances)
        or Expedition Number and URL to PDF'''

        print "resp = MRWebService.create_xmlrequest(self,vals)"
        xmlstring = MRWebService.create_xmlrequest(self, vals)

        print "resp = MRWebService.sendsoaprequest(self,xmlstring)"
        resp = MRWebService.sendsoaprequest(self,xmlstring)

        print "resp = MRWebService.parsexml(self,resp)"
        result = MRWebService.parsexmlresponse(self,resp)
        print "===== createetiquette final dict=====", result

        if labelformat == 'A4':
            url = result['URL_Etiquette']
        elif labelformat == 'A5':
            #TODO: just change 'format=A4' to 'format=A5' in the URL_Etiquette
            # don't need to call another webservice

            print " FORMAT A5"
            label_urls = MRWebService.get_label(self, vals, result)
            print "===== getetiquettes final dict ======"
            url = label_urls['url_pdf_a5']

        final = {
                'ExpeditionNum': result['ExpeditionNum'],
                'URL_Etiquette': url,
                'format':labelformat,
                }

        print "\n============== FINAL DICTIONNARY RETURNED ==============\n",final

        return final

